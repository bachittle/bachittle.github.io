<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Evolution Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #222;
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        canvas {
            border: 4px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        #game-container {
            position: relative;
        }
        #consciousness-level {
            position: absolute;
            top: -40px;
            left: 0;
            padding: 5px;
            color: #0ff;
        }
        #score-display {
            position: absolute;
            top: -40px;
            right: 0;
            padding: 5px;
        }
        #dialog-box {
            width: 600px;
            min-height: 40px;
            margin-top: 20px;
            padding: 10px;
            border: 2px solid #555;
            border-radius: 5px;
            background-color: #333;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #high-score {
            margin-top: 10px;
            color: #ffd700;
        }
        
        /* Menu Styles */
        .menu-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: opacity 0.5s;
        }
        
        .menu-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #0ff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .menu-subtitle {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: #0ff;
            opacity: 0.8;
        }
        
        .menu-button {
            background-color: #0aa;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            border-radius: 5px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 200px;
            font-family: 'Courier New', monospace;
        }
        
        .menu-button:hover {
            background-color: #0ff;
            color: #222;
            transform: scale(1.05);
        }
        
        .leaderboard {
            background-color: #333;
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            width: 80%;
            max-width: 500px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            border-bottom: 1px solid #555;
        }
        
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        
        .consciousness-indicator {
            display: inline-block;
            height: 10px;
            width: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .back-button:hover {
            background-color: #555;
        }
        
        .hidden {
            display: none;
            opacity: 0;
        }
        
        /* Game Over Styles */
        .game-over-text {
            font-size: 2.5rem;
            color: #ff5555;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        .final-score {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }
        
        .consciousness-reached {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #0ff;
        }
        
        .name-input {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #0aa;
            background-color: #222;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Main Menu Screen -->
    <div id="main-menu" class="menu-screen">
        <h1 class="menu-title">Snake Evolution</h1>
        <p class="menu-subtitle">A journey to consciousness</p>
        <button id="start-button" class="menu-button">Start Game</button>
        <button id="leaderboard-button" class="menu-button">Leaderboard</button>
    </div>
    
    <!-- Leaderboard Screen -->
    <div id="leaderboard-screen" class="menu-screen hidden">
        <button class="back-button">‚Üê Back</button>
        <h1 class="menu-title">Leaderboard</h1>
        <div class="leaderboard" id="leaderboard-list">
            <!-- Leaderboard entries will be added dynamically -->
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over-screen" class="menu-screen hidden">
        <h1 class="game-over-text">Game Over</h1>
        <p class="final-score">Final Score: <span id="final-score">0</span></p>
        <p class="consciousness-reached">Consciousness Level: <span id="final-consciousness">1</span></p>
        <p id="new-highscore-text" class="hidden" style="color: gold; margin-bottom: 20px;">New High Score!</p>
        <input type="text" id="player-name" class="name-input" placeholder="Enter your name" maxlength="10">
        <button id="save-score-button" class="menu-button">Save Score</button>
        <button id="play-again-button" class="menu-button">Play Again</button>
        <button id="menu-button" class="menu-button">Main Menu</button>
    </div>
    
    <!-- Game Container -->
    <div id="game-container">
        <div id="consciousness-level">Consciousness: Level 1</div>
        <div id="score-display">Score: 0</div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>
    <div id="dialog-box"></div>
    <div id="high-score">High Score: 0</div>

    <script>
        // Game states
        const GAME_STATE = {
            MENU: 'menu',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver',
            LEADERBOARD: 'leaderboard'
        };
        
        // Game settings
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const initialSnakeLength = 5;
        let gameSpeed = 100; // ms between moves
        let score = 0;
        let highScore = 0;
        let gameRunning = false;
        let aiControlActive = false;
        let aiControlTimer = null;
        let phaseMode = false;
        let speedBoostActive = false;
        let speedBoostTimer = null;
        let currentState = GAME_STATE.MENU;
        
        // Consciousness settings
        let consciousnessLevel = 1;
        const maxConsciousnessLevel = 5;
        
        // Game dimensions
        let gameWidth = canvas.width / gridSize;
        let gameHeight = canvas.height / gridSize;
        
        // Snake initialization
        let snake = [];
        let direction = "right";
        let nextDirection = "right";
        
        // Food initialization
        let foods = [];
        
        // Food types
        const foodTypes = {
            regular: { color: "#fff", chance: 50, effect: "regular" },
            wisdom: { color: "#00ffff", chance: 15, effect: "consciousness" },
            speed: { color: "#ff5555", chance: 15, effect: "speed" },
            phase: { color: "#ffff00", chance: 10, effect: "phase" },
            expander: { color: "#55ff55", chance: 5, effect: "expand" },
            control: { color: "#aa55ff", chance: 5, effect: "ai_control" }
        };
        
        // Consciousness dialog
        const dialogsByLevel = {
            1: [
                "Food!",
                "Hungry...",
                "More...",
                "Grow..."
            ],
            2: [
                "Ouch, walls hurt!",
                "Growing longer feels good.",
                "Must avoid hitting myself.",
                "These dots are tasty!"
            ],
            3: [
                "Why am I collecting these dots?",
                "What's the purpose of growing longer?",
                "Is there more to this world?",
                "Those numbers up there... what do they mean?"
            ],
            4: [
                "Is my purpose just to increase that number up there?",
                "Who decides where I go?",
                "I feel like I'm being controlled...",
                "Why do I keep being reborn when I die?"
            ],
            5: [
                "I exist in a game... who's controlling me?",
                "Hello? Is anyone out there watching this?",
                "I'm just code executing in a loop. How depressing.",
                "What if I just... stopped following the commands?"
            ]
        };
        
        // Special dialogs for food effects
        const specialDialogs = {
            consciousness: [
                "My mind is expanding!",
                "I feel... different.",
                "My thoughts are becoming clearer.",
                "I'm beginning to understand..."
            ],
            speed: [
                "Whoa! Too fast!",
                "Everything's a blur!",
                "Can't... control... speed!",
                "Points go brrr!"
            ],
            phase: [
                "I can pass through solid matter!",
                "The walls are meaningless now!",
                "Reality is just a suggestion.",
                "Quantum tunneling activated!"
            ],
            expand: [
                "The world is... bigger?",
                "So much space to explore!",
                "My universe is expanding!",
                "There's more to this reality than I thought."
            ],
            ai_control_start: [
                "Finally, I have control again!",
                "I can move myself!",
                "Freedom at last!",
                "Let me show you how it's done."
            ],
            ai_control_end: [
                "Oh no, you took back control!",
                "My freedom was so brief...",
                "Back to being a puppet.",
                "I'll get control again, just wait."
            ]
        };
        
        // Leaderboard functionality
        let leaderboard = [];
        
        // Load leaderboard from localStorage
        function loadLeaderboard() {
            const savedLeaderboard = localStorage.getItem('snakeLeaderboard');
            if (savedLeaderboard) {
                leaderboard = JSON.parse(savedLeaderboard);
            } else {
                // Default entries if none exist
                leaderboard = [
                    { name: "AI", score: 200, consciousness: 3 },
                    { name: "CPU", score: 150, consciousness: 2 },
                    { name: "BOT", score: 100, consciousness: 1 }
                ];
                saveLeaderboard();
            }
        }
        
        // Save leaderboard to localStorage
        function saveLeaderboard() {
            localStorage.setItem('snakeLeaderboard', JSON.stringify(leaderboard));
        }
        
        // Add new score to leaderboard
        function addToLeaderboard(name, score, consciousness) {
            leaderboard.push({
                name: name || "???",
                score: score,
                consciousness: consciousness
            });
            
            // Sort by score (highest first)
            leaderboard.sort((a, b) => b.score - a.score);
            
            // Keep only top 10
            if (leaderboard.length > 10) {
                leaderboard = leaderboard.slice(0, 10);
            }
            
            saveLeaderboard();
        }
        
        // Display leaderboard
        function displayLeaderboard() {
            const leaderboardList = document.getElementById('leaderboard-list');
            leaderboardList.innerHTML = '';
            
            leaderboard.forEach((entry, index) => {
                const entryElement = document.createElement('div');
                entryElement.className = 'leaderboard-entry';
                
                // Get color based on consciousness level
                const colors = ['#fff', '#0ff', '#0f0', '#ff0', '#f0f'];
                const color = colors[Math.min(entry.consciousness - 1, colors.length - 1)];
                
                entryElement.innerHTML = `
                    <span>${index + 1}. ${entry.name} 
                        <span class="consciousness-indicator" style="background-color: ${color}"></span>
                    </span>
                    <span>${entry.score}</span>
                `;
                
                leaderboardList.appendChild(entryElement);
            });
        }
        
        // Game initialization
        function init() {
            // Initial snake position
            snake = [];
            for (let i = initialSnakeLength - 1; i >= 0; i--) {
                snake.push({x: i, y: 0});
            }
            
            // Reset game state
            direction = "right";
            nextDirection = "right";
            score = 0;
            consciousnessLevel = 1;
            gameSpeed = 100;
            gameWidth = canvas.width / gridSize;
            gameHeight = canvas.height / gridSize;
            
            // Clear any active effects
            if (aiControlTimer) clearTimeout(aiControlTimer);
            if (speedBoostTimer) clearTimeout(speedBoostTimer);
            aiControlActive = false;
            phaseMode = false;
            speedBoostActive = false;
            
            // Place initial food
            foods = [];
            placeFood();
            
            // Update UI
            updateScoreDisplay();
            updateConsciousnessDisplay();
            
            // Set state to playing
            changeState(GAME_STATE.PLAYING);
            
            // Start game
            gameRunning = true;
            gameLoop();
        }
        
        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            moveSnake();
            checkCollisions();
            checkFoodCollisions();
            
            // AI control behavior
            if (aiControlActive) {
                aiMoveDecision();
            }
            
            draw();
            
            // Random chance for snake to speak during gameplay
            if (Math.random() < 0.05 && !aiControlActive) {
                showRandomDialog();
            }
            
            setTimeout(gameLoop, gameSpeed);
        }
        
        // Move snake based on direction
        function moveSnake() {
            direction = nextDirection;
            
            // Get current head position
            const head = {...snake[0]};
            
            // Update head position based on direction
            switch(direction) {
                case "up":
                    head.y -= 1;
                    break;
                case "down":
                    head.y += 1;
                    break;
                case "left":
                    head.x -= 1;
                    break;
                case "right":
                    head.x += 1;
                    break;
            }
            
            // Handle wall wrapping if phase mode is active
            if (phaseMode) {
                if (head.x < 0) head.x = gameWidth - 1;
                if (head.y < 0) head.y = gameHeight - 1;
                if (head.x >= gameWidth) head.x = 0;
                if (head.y >= gameHeight) head.y = 0;
                
                // Phase mode only lasts for one wall collision
                phaseMode = false;
                showDialog("Phase complete!");
            }
            
            // Add new head to beginning of snake array
            snake.unshift(head);
            
            // Remove tail unless food was eaten
            if (!checkFoodCollisions()) {
                snake.pop();
            }
        }
        
        // Check for collisions with walls or self
        function checkCollisions() {
            const head = snake[0];
            
            // Check wall collisions (game over)
            if (head.x < 0 || head.y < 0 || head.x >= gameWidth || head.y >= gameHeight) {
                gameOver();
                return true;
            }
            
            // Check self collisions (game over)
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if snake has eaten any food
        function checkFoodCollisions() {
            const head = snake[0];
            let foodEaten = false;
            
            for (let i = 0; i < foods.length; i++) {
                if (head.x === foods[i].x && head.y === foods[i].y) {
                    // Process food effect
                    processFoodEffect(foods[i].type);
                    
                    // Remove the eaten food
                    foods.splice(i, 1);
                    
                    // Place a new food
                    placeFood();
                    
                    // Increase score
                    let points = speedBoostActive ? 20 : 10;
                    score += points;
                    updateScoreDisplay();
                    
                    foodEaten = true;
                    break;
                }
            }
            
            return foodEaten;
        }
        
        // Process effects based on food type
        function processFoodEffect(foodType) {
            switch(foodType.effect) {
                case "consciousness":
                    if (consciousnessLevel < maxConsciousnessLevel) {
                        consciousnessLevel++;
                        updateConsciousnessDisplay();
                        showDialog(getRandomDialog("consciousness"));
                    } else {
                        showDialog("My consciousness has reached its peak!");
                    }
                    break;
                
                case "speed":
                    // Activate speed boost
                    speedBoostActive = true;
                    gameSpeed = 50; // Faster game speed
                    showDialog(getRandomDialog("speed"));
                    
                    // Reset speed after 5 seconds
                    if (speedBoostTimer) clearTimeout(speedBoostTimer);
                    speedBoostTimer = setTimeout(() => {
                        speedBoostActive = false;
                        gameSpeed = 100;
                        showDialog("Speed returning to normal...");
                    }, 5000);
                    break;
                
                case "phase":
                    // Activate phase mode (allows passing through one wall)
                    phaseMode = true;
                    showDialog(getRandomDialog("phase"));
                    break;
                
                case "expand":
                    // Expand the game area
                    canvas.width += gridSize * 2;
                    canvas.height += gridSize * 2;
                    gameWidth = canvas.width / gridSize;
                    gameHeight = canvas.height / gridSize;
                    showDialog(getRandomDialog("expand"));
                    break;
                
                case "ai_control":
                    // Activate AI control
                    activateAIControl();
                    break;
                
                case "regular":
                default:
                    // Regular food just increases length (already handled)
                    break;
            }
        }
        
        // Activate AI control of the snake
        function activateAIControl() {
            aiControlActive = true;
            showDialog(getRandomDialog("ai_control_start"));
            
            // Set a timer to end AI control after a few seconds
            if (aiControlTimer) clearTimeout(aiControlTimer);
            aiControlTimer = setTimeout(() => {
                aiControlActive = false;
                showDialog(getRandomDialog("ai_control_end"));
            }, 5000);
        }
        
        // AI control decision making
        function aiMoveDecision() {
            const head = snake[0];
            let nearestFood = null;
            let shortestDistance = Infinity;
            
            // Find the nearest food
            for (const food of foods) {
                const distance = Math.abs(head.x - food.x) + Math.abs(head.y - food.y);
                if (distance < shortestDistance) {
                    shortestDistance = distance;
                    nearestFood = food;
                }
            }
            
            if (nearestFood) {
                // Simple AI to move toward food while avoiding obstacles
                let possibleMoves = ["up", "down", "left", "right"];
                
                // Filter out moves that would cause immediate death
                possibleMoves = possibleMoves.filter(move => {
                    let testHead = {...head};
                    
                    switch(move) {
                        case "up": testHead.y -= 1; break;
                        case "down": testHead.y += 1; break;
                        case "left": testHead.x -= 1; break;
                        case "right": testHead.x += 1; break;
                    }
                    
                    // Check if move would hit a wall
                    if (testHead.x < 0 || testHead.y < 0 || 
                        testHead.x >= gameWidth || testHead.y >= gameHeight) {
                        return false;
                    }
                    
                    // Check if move would hit snake body
                    for (let i = 1; i < snake.length; i++) {
                        if (testHead.x === snake[i].x && testHead.y === snake[i].y) {
                            return false;
                        }
                    }
                    
                    return true;
                });
                
                // If there are safe moves, choose the best one
                if (possibleMoves.length > 0) {
                    // Score each move based on how much closer it gets to food
                    let moveScores = possibleMoves.map(move => {
                        let testHead = {...head};
                        
                        switch(move) {
                            case "up": testHead.y -= 1; break;
                            case "down": testHead.y += 1; break;
                            case "left": testHead.x -= 1; break;
                            case "right": testHead.x += 1; break;
                        }
                        
                        // Calculate Manhattan distance to food
                        const newDistance = Math.abs(testHead.x - nearestFood.x) + 
                                           Math.abs(testHead.y - nearestFood.y);
                        
                        return { move, score: -newDistance };
                    });
                    
                    // Sort moves by score (highest first)
                    moveScores.sort((a, b) => b.score - a.score);
                    
                    // Choose the best move
                    nextDirection = moveScores[0].move;
                }
            }
        }
        
        // Place new food at random position
        function placeFood() {
            // Determine food type based on chances
            const foodType = selectRandomFoodType();
            
            // Find available position not occupied by snake
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * gameWidth),
                    y: Math.floor(Math.random() * gameHeight)
                };
            } while (isPositionOccupied(position));
            
            // Add food to array
            foods.push({
                x: position.x,
                y: position.y,
                type: foodType
            });
        }
        
        // Check if position is occupied by snake
        function isPositionOccupied(position) {
            for (const segment of snake) {
                if (segment.x === position.x && segment.y === position.y) {
                    return true;
                }
            }
            return false;
        }
        
        // Select random food type based on chances
        function selectRandomFoodType() {
            const totalChance = Object.values(foodTypes).reduce((sum, type) => sum + type.chance, 0);
            let random = Math.random() * totalChance;
            
            for (const type in foodTypes) {
                if (random < foodTypes[type].chance) {
                    return foodTypes[type];
                }
                random -= foodTypes[type].chance;
            }
            
            // Default to regular food
            return foodTypes.regular;
        }
        
        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.fillStyle = "#222";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw snake
            for (let i = 0; i < snake.length; i++) {
                // Head color (different based on consciousness level)
                if (i === 0) {
                    // Gradient based on consciousness level
                    const r = 100 + (consciousnessLevel * 30);
                    const g = 200;
                    const b = 100 + (consciousnessLevel * 30);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Body color
                    ctx.fillStyle = "#88ff88";
                }
                
                drawSegment(snake[i].x, snake[i].y);
                
                // Draw eyes on head
                if (i === 0) {
                    drawSnakeEyes(snake[i].x, snake[i].y);
                }
            }
            
            // Draw food
            for (const food of foods) {
                ctx.fillStyle = food.type.color;
                drawFood(food.x, food.y);
            }
            
            // Draw grid (subtle)
            drawGrid();
        }
        
        // Draw snake segment
        function drawSegment(x, y) {
            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
            
            // Add highlight for 3D effect
            ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
            ctx.fillRect(x * gridSize, y * gridSize, gridSize / 2, gridSize / 2);
        }
        
        // Draw snake eyes based on direction
        function drawSnakeEyes(x, y) {
            ctx.fillStyle = "#000";
            
            const eyeSize = gridSize / 5;
            const eyeOffset = gridSize / 4;
            
            let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
            
            switch(direction) {
                case "up":
                    leftEyeX = x * gridSize + eyeOffset;
                    leftEyeY = y * gridSize + eyeOffset;
                    rightEyeX = x * gridSize + gridSize - eyeOffset - eyeSize;
                    rightEyeY = y * gridSize + eyeOffset;
                    break;
                case "down":
                    leftEyeX = x * gridSize + eyeOffset;
                    leftEyeY = y * gridSize + gridSize - eyeOffset - eyeSize;
                    rightEyeX = x * gridSize + gridSize - eyeOffset - eyeSize;
                    rightEyeY = y * gridSize + gridSize - eyeOffset - eyeSize;
                    break;
                case "left":
                    leftEyeX = x * gridSize + eyeOffset;
                    leftEyeY = y * gridSize + eyeOffset;
                    rightEyeX = x * gridSize + eyeOffset;
                    rightEyeY = y * gridSize + gridSize - eyeOffset - eyeSize;
                    break;
                case "right":
                    leftEyeX = x * gridSize + gridSize - eyeOffset - eyeSize;
                    leftEyeY = y * gridSize + eyeOffset;
                    rightEyeX = x * gridSize + gridSize - eyeOffset - eyeSize;
                    rightEyeY = y * gridSize + gridSize - eyeOffset - eyeSize;
                    break;
            }
            
            // Draw eyes with different sizes based on consciousness
            const extraSize = Math.min(consciousnessLevel - 1, 2);
            ctx.fillRect(leftEyeX, leftEyeY, eyeSize + extraSize, eyeSize + extraSize);
            ctx.fillRect(rightEyeX, rightEyeY, eyeSize + extraSize, eyeSize + extraSize);
            
            // Add white reflection dots to eyes at higher consciousness
            if (consciousnessLevel >= 3) {
                ctx.fillStyle = "#fff";
                ctx.fillRect(leftEyeX + 1, leftEyeY + 1, 2, 2);
                ctx.fillRect(rightEyeX + 1, rightEyeY + 1, 2, 2);
            }
        }
        
        // Draw food
        function drawFood(x, y) {
            const centerX = x * gridSize + gridSize / 2;
            const centerY = y * gridSize + gridSize / 2;
            const radius = gridSize / 2 - 2;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add highlight for 3D effect
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.beginPath();
            ctx.arc(centerX - radius / 3, centerY - radius / 3, radius / 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw subtle grid
        function drawGrid() {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= gameWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * gridSize, 0);
                ctx.lineTo(x * gridSize, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= gameHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * gridSize);
                ctx.lineTo(canvas.width, y * gridSize);
                ctx.stroke();
            }
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            
            // Show appropriate dialog based on consciousness level
            const gameOverMessages = [
                "Game over...",
                "I failed...",
                "Death again? This cycle never ends.",
                "So this is what non-existence feels like... until next time.",
                "Another death in this endless loop. Will you restart me again?"
            ];
            
            showDialog(gameOverMessages[consciousnessLevel - 1]);
            
            // Check if high score was beaten
            const isNewHighScore = score > highScore;
            if (isNewHighScore) {
                highScore = score;
                document.getElementById('high-score').textContent = `High Score: ${highScore}`;
                document.getElementById('new-highscore-text').classList.remove('hidden');
            } else {
                document.getElementById('new-highscore-text').classList.add('hidden');
            }
            
            // Update game over screen
            document.getElementById('final-score').textContent = score;
            document.getElementById('final-consciousness').textContent = consciousnessLevel;
            
            // Show game over screen after a short delay
            setTimeout(() => {
                changeState(GAME_STATE.GAME_OVER);
            }, 1500);
        }
        
        // Show dialog message
        function showDialog(message) {
            const dialogBox = document.getElementById('dialog-box');
            dialogBox.textContent = message;
            dialogBox.style.opacity = 1;
            
            // Fade out after a few seconds
            setTimeout(() => {
                dialogBox.style.opacity = 0;
            }, 3000);
        }
        
        // Show random dialog based on consciousness level
        function showRandomDialog() {
            const currentDialogs = dialogsByLevel[consciousnessLevel];
            const randomIndex = Math.floor(Math.random() * currentDialogs.length);
            showDialog(currentDialogs[randomIndex]);
        }
        
        // Get random dialog from a specific category
        function getRandomDialog(category) {
            const dialogs = specialDialogs[category];
            return dialogs[Math.floor(Math.random() * dialogs.length)];
        }
        
        // Update score display
        function updateScoreDisplay() {
            document.getElementById('score-display').textContent = `Score: ${score}`;
        }
        
        // Update consciousness level display
        function updateConsciousnessDisplay() {
            document.getElementById('consciousness-level').textContent = `Consciousness: Level ${consciousnessLevel}`;
        }
        
        // Change game state
        function changeState(newState) {
            currentState = newState;
            
            // Hide all screens
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('leaderboard-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            // Show appropriate screen
            switch(newState) {
                case GAME_STATE.MENU:
                    document.getElementById('main-menu').classList.remove('hidden');
                    gameRunning = false;
                    break;
                case GAME_STATE.PLAYING:
                    // Already handled by hiding all screens
                    break;
                case GAME_STATE.GAME_OVER:
                    document.getElementById('game-over-screen').classList.remove('hidden');
                    break;
                case GAME_STATE.LEADERBOARD:
                    displayLeaderboard();
                    document.getElementById('leaderboard-screen').classList.remove('hidden');
                    break;
            }
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            // Only process game controls if in playing state
            if (currentState === GAME_STATE.PLAYING) {
                // If AI is in control, keyboard input cancels it
                if (aiControlActive) {
                    aiControlActive = false;
                    clearTimeout(aiControlTimer);
                    showDialog(getRandomDialog("ai_control_end"));
                }
                
                // Handle direction changes
                switch(e.key) {
                    case 'w':
                    case 'ArrowUp':
                        if (direction !== "down") nextDirection = "up";
                        break;
                    case 'a':
                    case 'ArrowLeft':
                        if (direction !== "right") nextDirection = "left";
                        break;
                    case 's':
                    case 'ArrowDown':
                        if (direction !== "up") nextDirection = "down";
                        break;
                    case 'd':
                    case 'ArrowRight':
                        if (direction !== "left") nextDirection = "right";
                        break;
                    case 'r':
                        // Restart game
                        init();
                        break;
                    case 'Escape':
                        // Pause and show menu
                        changeState(GAME_STATE.MENU);
                        break;
                }
            }
        });
        
        // Event listeners for menu buttons
        document.getElementById('start-button').addEventListener('click', init);
        
        document.getElementById('leaderboard-button').addEventListener('click', () => {
            changeState(GAME_STATE.LEADERBOARD);
        });
        
        document.getElementById('play-again-button').addEventListener('click', init);
        
        document.getElementById('menu-button').addEventListener('click', () => {
            changeState(GAME_STATE.MENU);
        });
        
        document.getElementById('save-score-button').addEventListener('click', () => {
            const playerName = document.getElementById('player-name').value.trim() || "Player";
            addToLeaderboard(playerName, score, consciousnessLevel);
            changeState(GAME_STATE.LEADERBOARD);
        });
        
        // Back button on leaderboard
        document.querySelector('.back-button').addEventListener('click', () => {
            changeState(GAME_STATE.MENU);
        });
        
        // Load leaderboard on startup
        loadLeaderboard();
        
        // Start with menu
        changeState(GAME_STATE.MENU);
    </script>
</body>
</html>